* DONE make s22() const                                             :ARCHIVE:
introduce method 
   compute_KS_invariants()
to Space, Space_family & Deque_of_Space_families

* DONE static CONSTANTS                                             :ARCHIVE:
for s22() unkown        (not yet computed)
for s22() uncomputable  (condition C fails)
* DONE renaming                                                     :ARCHIVE:
Space_family             -->  SpaceTuple
Deque_of_Space_families  -->  SpaceTupleList
   
* DONE Config: DATA types                                           :ARCHIVE:
* DONE Config: max-lines-per-file                                   :ARCHIVE:
* DONE print ?? if s22() unkown                                     :ARCHIVE:
print WARNING if condition C fails
* DONE print statistics to screen                                   :ARCHIVE:
* DONE move esch_generate to esch_families                          :ARCHIVE:
* DONE Constructors                                                 :ARCHIVE:
* DONE Filters -- idea "invariants"                                 :ARCHIVE:

HomotopyClass(E1) returns "tuple" |s22|, sgn(s22,s), |s|, |r|
(of type deque<boost::variant<long, rational<long long>>)

vector<boost::variant<...>> homotopyClass(const Space &E)
{
   my_var.pushback(|s22|), 
   my_var.pushback(sign(s22,s)), 
   ... 
   return my_var
}

class IsoClass
{
}



class HomotopyClass : parent IsoClass
{
  rational abs_s22
  long abs_s2
  int sign
  long r
  long abs_s


}


* Filters -- idea "Test"                                            :ARCHIVE:
user interface:

   Test::HomotopyClass.is_equal(E1,E2)


** esch_tests.h:

Test
   is_equal(E1,E2)
   is_greater(E1,E2)

Test::HomotopyClass
   equal(E1,E2):
   - |s22|, sgn(s22,s), |s|, |r| agree
   greater(E1,E2):
   - |s22|, sgn(s22,s), |s|, |r|  

Test::TangentialHomotopyClass
   - Test::HomotopyClass.is_equal & p agrees
   - ....

Test::Homeomorphism
   - Test::HomotopyClass.is_equal & |s2| & sign(s2,s) agree
   - ...

** esch_families:   <-- should include esch_generate

Deque_of_Space_families:
   + method generate_rs_families
   + method filter
     pass above Test objects as parameter

** aux_math:

sgn(p/q,s) =  1 if 1/2 > p/q > 0 and s > 0
sgn(p/q,s) =  0 if 1/2 = p/q  OR  p/q = 0  OR  s = 0
sgn(p/q,s) = -1 if (1/2 > p/q > 0  and s < 0)  OR  (0 > p/q > -1/2  and s > 0)

To compute it, define
    sgn(s) = 1 / 0 / -1
  sgn(p/q) = 1 / 0 / -1
and multiply these together.


** OLD TEST CODE

class Test
{
  static bool equal(const Space& E1, const Space& E2); //placeholder for overloading later
  static bool greater(const Space& E1, const Space& E2); //placeholder for overloading later
};
class HomotopyClass : Test
{
  static bool equal(const Space& E1, const Space& E2)
  {
    if (abs(E1.s22()) != abs(E2.s22())) return false;
    if (sign(E1.s22)*sign(E1.s()) != sign(E1.s22)*sign(E2.s())) return false;
    if (abs(E1.s()) != abs(E2.s())) return false;
    if (abs(E1.r()) != abs(E2.r())) return false;
  }
  static int compareHomotopyClass(const Space& E1, const Space&E2)
  { 
    if (abs(E1.s22()) > abs(E2.s22())) return 1;
    if (abs(E1.s22()) < abs(E2.s22())) return -1;
    if (sign(E1.s22())*sign(E1.s()) > sign(E2.s22())*sign(E2.s())) return 1;
    if (sign(E1.s22())*sign(E1.s()) < sign(E2.s22())*sign(E2.s())) return -1;
    if (abs(E1.s()) > abs(E2.s())) return 1;
    if (abs(E1.s()) < abs(E2.s())) return -1;
    if (abs(E1.r()) > abs(E2.r())) return 1;
    if (abs(E1.s()) <= abs(E2.s())) return -1;
  }
} homotopyClass;

class TangentialHomotopyClass : Test
{
  static bool equal(const Space& E1, const Space& E2)
  {
    if (abs(E1.s22()) != abs(E2.s22())) return false;
    if (sign(E1.s22)*sign(E1.s()) != sign(E1.s22)*sign(E2.s())) return false;
    if (abs(E1.s()) != abs(E2.s())) return false;
    if (abs(E1.r()) != abs(E2.r())) return false;
  }
  static bool greater(const Space& E1, const Space&E2)
  { 
    if (abs(E1.s22()) > abs(E2.s22())) return true;
    if (abs(E1.s22()) < abs(E2.s22())) return false;
    if (sign(E1.s22())*sign(E1.s()) > sign(E2.s22())*sign(E2.s())) return true;
    if (sign(E1.s22())*sign(E1.s()) < sign(E2.s22())*sign(E2.s())) return false;
    if (abs(E1.s()) > abs(E2.s())) return true;
    if (abs(E1.s()) < abs(E2.s())) return false;
    if (abs(E1.r()) > abs(E2.r())) return true;
    if (abs(E1.s()) <= abs(E2.s())) return false;
  }
};
   
* DONE read command line                                            :ARCHIVE:
  
* DONE print instructions for usage when stated without command line parameters  :ARCHIVE:
* Documentation
** Main README
*** Installation notes
**** CONFIG options
--> data types
*** Relation to [CEZ06]
and to maple code
which functions are implemented?
*** File structure
** Implementation notes (separate files on doc folder)
*** data types

| int       | 4 bytes | ± 2^{31} |
| long      | 4 bytes | ± 2^{31} |
| long long | 8 bytes | ± 2^{63} |
|           |         |          |

Note: 10^{6} < 2^{20}

So for R ≤ 1.000.000 have
r ≤ 2^{20}
k1 ≤ 2^{10}
denominators/numerators of s2 and s22 ~ 2^{50}

! for spaces generated by algorithm, parameters are bounded by sqrt(R) !
! but in general, parameters are NOT bounded by R, right?              !
So should state:

If absolute values of parameters of Eschenburg spaces are bounded by P, 
then |r| is bounded by R = 6·P².
: |r| ≤ |k₁k₂+k₁k₃+k₂k₃-l₁l₂-l₁l₃-l₂l₃|
In the standard presentation used by the algorithm for generating Eschenburg spaces, 
if |r| is bounded by R, then conversely the absolute values of parameters are bounded by 2R^{1/2}
(factor 2 because l3 = -n-d).
Summary:

:  |r| ≤ 2³P²  ⇐ |kᵢ|, |lᵢ| ≤ P          in general                 (⇒ R·P³ ≤ 2³P⁵     )
:  |r| ≤ R     ⇒ |kᵢ|, |lᵢ| ≤ 2R^{1/2}   for standard presentation. (⇒ R·P³ ≤ 2³R^{5/2})

Assume either:
(A) Space arbitrary,                 R ≤ 2^{21}  ⇐   P ≤ 2^{9}     (⇒ R·P³ ≤ 2^{48})
(B) Space in standard presentation,  R ≤ 2^{18}  ⇒   P ≤ 2^{10}    (⇒ R·P³ ≤ 2^{44})

(A') Space arbitrary,                 R ≤ 2^{19}  ⇐   P ≤ 2^{8}    (⇒ R·P³ ≤ 2^{43})
(B') Space in standard presentation,  R ≤ 2^{16}  ⇒   P ≤ 2^{9}    (⇒ R·P³  ≤ 2^{43})

2^{8}  =  256
2^{9}  =  512
2^{10} = 1024
2^{16} =  256² >~    62.500
2^{18} =  512² >~   250.000
2^{20} = 1024² >= 1.000.000

:  11 + 5e_P       ≤ 63    ⇐  e_P ≤ 10
:  20 + 3e_P + e_R ≤ 63    ⇐  e_R ≤ 16   AND   e_P ≤  9

In both cases,
: R·P³ ≤ 2^{49}  ← need this for d
: R·P² ≤ 2^{43}  ← need this for denominator of s2!
 
**** Computation of s2 & s22
The invariant s2 is calculated by an expression of the form 
: s2  = (q-2)/d + SUM,
where SUM is a sum of four lens space invariants.

***** The integers q and d :
The absolute value of q is bounded by a sum of six squares of differences of parameters (kᵢ-lⱼ).  
: |kᵢ-lⱼ|² ≤ (2P)² = 2²P²
So |q| ≤  6·2²P² ≤ 2⁵P² = 2^{5 + 2e_P}
`|d|` is bounded by 
: |d| ≤ 3·2⁴·R·(2P)³
:     ≤ 3·2^{7}·R·P³
:     ≤ 2^{9}·R·P³
: |d| ≤ 2^{9 + e_R + 3e_P} 

#+BEGIN_ASIDE
standard presentation:
Only one of the factors kᵢ-lⱼ involve k₃ and is hence bounded by 2P.
The other two factors are bounded by P.  So in this case |d| is bounded by 
: |d| ≤ 3·2⁴·R·2³·2P³
:     ≤ 2^{12 + e_R + 3e_P}    
#+END_ASIDE

Any upper bound for |d| wil also be upper bound for |q|.  
Under assumptions above, upper bound for |d| is:
: |d| ≤ 2^{14+49} = 2^{63}
--> need 64-bit integer for d, i.e. a long long.

***** Lens invariants 
Each lens invariant is a sum of p summands of the form
:   |cos(…)-1|·|1/sin(kπp₁/p)|·|1/sin(kπp₂/p)|·|1/sin(kπp₃/p)|·| 1/sin(kπp₄/p)|
When |x| is small, |sin(x)| ~ |x|, so an upper bound for such a summand can be estimated as
:   |cos(…)-1|·|p/(kπp₁)|·|p/(kπp₂)|·|p/(kπp₃)|·|p/(kπp₄)|
: ≤ 2·|p⁴/π⁴|
: ≤ 2^{-5} |p⁴/k⁴|   (since π² > 2³)
Summing up all of these over k = 1, ..., p, we obtain
: |s| ≤ 2^{-5} |p⁴|(1 + 1/2⁴ + 1/3⁴ + 1/4⁴ + .... + 1/P⁴)
:     ≤ 2^{-4} |p⁴|           
:     ≤ P^{4}     (since |p| ≤ 2P)
:     ≤ 2^{4e_P}
as an upper bound for each lens invariant.

⇒ |45s| ≤ 64|s| ≤ 2^{4e_P}

Under assumptions above, P < 2^{10}, so
:  |45s| ≤ 2^{40}

⇒ need 41-bit Mantissa :)

***** s22
Need consider
: s22 = (q-2)/d + (45lens₁/ 45) + (45lens₂ / 45) + (45lens₃ / 45)
:     = (45(q-2) + 45lens₁ + 45lens₂ + 45lens₃)/(45d)

SO I WANT to be able to store integer of size 
: |s22.numerator  | ≤ 45·2^{5 + 2e_P} + 4·45·2^{1 + 4e_P}
:                   ≤ 2^{6}·(2^{5 + 2e_P} + 2^{3 + 4e_P})
:                   ≤ 2^{7}·(2^{3 + 4e_P})    (assuming e_P ≥ 1)
:                   = 2^{10 + 4e_P}
: |s22.denominator| ≤ 45d
:                   ≤ 2^{6}d 
:                   ≤ 2^{20 + e_R + 3e_P}

For long long, need
:  11 + 5e_P       ≤ 63    ⇐  e_P ≤ 10
:  20 + 3e_P + e_R ≤ 63    ⇐  e_P ≤  9   AND   e_R ≤ 16


*** routine for generation of rs_tuples (algorithm)
deque of deques  --> history
*** routine for generation of rs_tuples (history)


** compiling for windows from windos:
MingGW compiler for windows including boost libraries:
https://nuwen.net/mingw.html

** compiling for windows from ubuntu:
Some brief instructions are here:
https://arrayfire.com/cross-compile-to-windows-from-linux/

Install mingw:
: sudo apt-get install mingw-w64
 
Run mingw as:
: x86_64-w64-mingw32-g++ -std=c++11 -I/usr/local/include/boost_1_65_1 -static-libgcc -static-libstdc++ -static -O3
followed by the usual command line options for gcc, eg
: x86_64-w64-mingw32-g++ -std=c++11 -I/usr/local/include/boost_1_65_1 -static-libgcc -static-libstdc++ -static -O3 hello.c -o hello.exe
Note that there is no "=" between "-I" and "/usr/local...".


* NOTES
** boost
On top115, I've removed the standard installation and instead installed manually (see below) into :

: /usr/local/include/boost_1_65_1

The cpp compiler therefore now needs to be called with the additional flag

: -I=/usr/local/include/boost_1_65_1
  
(The standard #include paths for gcc include
: /usr/local/include
but, it seems, not the subdirectory
: /usr/local/include/boost_1_65_1
For a list of directories in which gcc searches, run
: gcc -xc++ -E -v -
(https://stackoverflow.com/a/6666338/3611932))

*** boost installation:
: wget 'http://sourceforge.net/projects/boost/files/latest/download?source=files' -O boost.tar.gz
: tar 7z -x boost.tar.gz
